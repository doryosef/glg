/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 113);
/******/ })
/************************************************************************/
/******/ ({

/***/ 113:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(125);

var _reactRouter = __webpack_require__(211);

var _Layout = __webpack_require__(237);

var _Layout2 = _interopRequireDefault(_Layout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function buildRoutes() {
    return _react2.default.createElement(
        _reactRouter.Router,
        { history: _reactRouter.browserHistory },
        _react2.default.createElement(_reactRouter.Route, { path: '/', component: _Layout2.default })
    );
}

(0, _reactDom.render)(buildRoutes(), document.getElementById('glg'));

/***/ }),

/***/ 125:
/***/ (function(module, exports) {

"use strict";
throw new Error("Module build failed: Error: ENOENT: no such file or directory, open 'C:\\UwAmp\\www\\glg\\client\\node_modules\\react-dom\\index.js'\n    at Error (native)");

/***/ }),

/***/ 211:
/***/ (function(module, __webpack_exports__) {

"use strict";
throw new Error("Module build failed: Error: ENOENT: no such file or directory, open 'C:\\UwAmp\\www\\glg\\client\\node_modules\\react-router\\es\\index.js'\n    at Error (native)");

/***/ }),

/***/ 237:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _graph = __webpack_require__(238);

var _graph2 = _interopRequireDefault(_graph);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Layout = function (_React$Component) {
    _inherits(Layout, _React$Component);

    function Layout(props) {
        _classCallCheck(this, Layout);

        var _this = _possibleConstructorReturn(this, (Layout.__proto__ || Object.getPrototypeOf(Layout)).call(this, props));

        _this.state = { viewers: null };
        return _this;
    }

    _createClass(Layout, [{
        key: "render",
        value: function render() {
            console.log(this.state);
            var graphView = _graph2.default.draw();
            return _react2.default.createElement(
                "div",
                null,
                _react2.default.createElement(
                    "div",
                    { className: "gcv-container" },
                    graphView
                )
            );
        }
    }]);

    return Layout;
}(_react2.default.Component);

exports.default = Layout;

/***/ }),

/***/ 238:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = __webpack_require__(6);

var _react2 = _interopRequireDefault(_react);

var _data = __webpack_require__(239);

var _data2 = _interopRequireDefault(_data);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var BRANCH = 0;
var DATE = 1;
var MSG = 2;

var graph = {
    draw: function draw() {
        var _this = this;

        this.branches = this.init();
        var graphView = [];
        var currBranches = [];

        _data2.default.map(function (commit, i) {
            var branchIdx = Object.keys(_this.branches).indexOf(commit[BRANCH]);

            //branch ended part
            //end last branch
            if (_data2.default.length - 1 === i) {
                var branchClass = { color: _this.toHexColor(commit[BRANCH]) };
                graphView.push(_react2.default.createElement(
                    "div",
                    { key: Math.random() },
                    _react2.default.createElement(
                        "span",
                        { style: branchClass },
                        "* "
                    ),
                    " ",
                    commit[DATE],
                    " | ",
                    commit[MSG]
                ));
                return;
            }
            //end and merge current branch
            Object.keys(_this.branches).map(function (bName) {
                if (_this.branches[bName] === i) {
                    (function () {
                        var horLine = [];
                        var horLine2 = [];
                        var isAfterBranchEnd = false;
                        currBranches.map(function (cb, j) {
                            var b = commit[BRANCH].split(/</);
                            var branchClass = { color: _this.toHexColor(cb) };
                            if (cb === b[1]) {
                                isAfterBranchEnd = true;
                                horLine.push(_react2.default.createElement(
                                    "span",
                                    { key: Math.random(), style: branchClass },
                                    "\\ "
                                ));
                                horLine2.splice(horLine2.length - 1, 1, _react2.default.createElement(
                                    "span",
                                    { key: Math.random(), style: branchClass },
                                    "* "
                                ));
                            } else {
                                horLine.push(_react2.default.createElement(
                                    "span",
                                    { key: Math.random(), style: branchClass },
                                    isAfterBranchEnd ? "\\ " : "| "
                                ));
                                horLine2.push(_react2.default.createElement(
                                    "span",
                                    { key: Math.random(), style: branchClass },
                                    isAfterBranchEnd ? "| " : "\\ "
                                ));
                            }
                        });
                        graphView.push(_react2.default.createElement(
                            "div",
                            { key: Math.random() },
                            horLine
                        ));
                        graphView.push(_react2.default.createElement(
                            "div",
                            { key: Math.random() },
                            horLine2,
                            " ",
                            commit[DATE],
                            " | ",
                            commit[MSG]
                        ));
                        currBranches.splice(currBranches.indexOf(bName), 1);
                    })();
                }
            });

            //master start
            if (i === 0) {
                currBranches.push(commit[BRANCH]);
                var _branchClass = { color: _this.toHexColor(commit[BRANCH]) };
                graphView.push(_react2.default.createElement(
                    "div",
                    { key: Math.random() },
                    _react2.default.createElement(
                        "sapn",
                        { style: _branchClass },
                        "* "
                    ),
                    " ",
                    commit[DATE],
                    " | ",
                    commit[MSG]
                ));
            }
            //creating branch
            else if (commit[BRANCH].includes(">")) {
                    (function () {
                        var b = commit[BRANCH].split(/>/);
                        currBranches.push(b[1]);

                        var horLine = [];
                        var horLine2 = [];
                        currBranches.map(function (cb, j) {
                            var branchClass = { color: _this.toHexColor(cb) };
                            horLine.push(_react2.default.createElement(
                                "span",
                                { key: Math.random(), style: branchClass },
                                " ",
                                cb === b[1] ? "/ " : "| "
                            ));
                            horLine2.push(_react2.default.createElement(
                                "span",
                                { key: Math.random(), style: branchClass },
                                cb === b[1] ? "*  " : "| "
                            ));
                        });
                        graphView.push(_react2.default.createElement(
                            "div",
                            { key: Math.random() },
                            horLine
                        ));
                        graphView.push(_react2.default.createElement(
                            "div",
                            { key: Math.random() },
                            horLine2,
                            " ",
                            commit[DATE],
                            " | ",
                            commit[MSG]
                        ));
                    })();
                }
                //merging back
                else if (commit[BRANCH].includes("<")) {
                        var b = commit[BRANCH].split(/</);
                    }
                    //new branch
                    else if (branchIdx === -1) {
                            currBranches.push(commit[BRANCH]);
                            graphView.push(_react2.default.createElement(
                                "div",
                                { key: Math.random() },
                                "|/ ",
                                commit[DATE],
                                " | ",
                                commit[MSG]
                            ));
                        }
                        //commit
                        else {
                                (function () {
                                    var horLine = [];
                                    currBranches.map(function (cb, j) {
                                        var branchClass = { color: _this.toHexColor(cb) };
                                        horLine.push(_react2.default.createElement(
                                            "span",
                                            { key: cb + "_" + i + "_" + j, style: branchClass },
                                            cb === commit[BRANCH] ? "* " : "| "
                                        ));
                                        //horLine = cb === commit[BRANCH] ? horLine + "* " : horLine + "| ";
                                    });
                                    graphView.push(_react2.default.createElement(
                                        "div",
                                        { key: Math.random() },
                                        horLine,
                                        " ",
                                        commit[DATE],
                                        " | ",
                                        commit[MSG]
                                    ));
                                })();
                            }
        });
        return graphView.reverse();
    },
    init: function init() {
        var _this2 = this;

        this.branches = {};

        //getting branches exist and when ended
        _data2.default.map(function (commit, i) {
            var branchIdx = Object.keys(_this2.branches).indexOf(commit[BRANCH]);
            if (commit[BRANCH].includes("<") || commit[BRANCH].includes(">")) {
                var b = commit[BRANCH].split(/>|</);
                _this2.branches[b[0]] = i;
                _this2.branches[b[1]] = i;
            } else if (branchIdx === -1) {
                Object.assign(_this2.branches, _defineProperty({}, commit[BRANCH], i));
            } else {
                _this2.branches[commit[BRANCH]] = i;
            }
        });
        return this.branches;
    },


    /* credit for solution converting string to rgb hex code
     * designedbyaturtle.co.uk/2014/convert-string-to-hexidecimal-colour-with-javascript-vanilla
     */
    toHexColor: function toHexColor(str) {
        return "#" + this.intToARGB(this.hashCode(str));
    },
    hashCode: function hashCode(str) {
        var hash = 0;
        for (var i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        return hash;
    },
    intToARGB: function intToARGB(i) {
        var hex = (i >> 24 & 0xFF).toString(16) + (i >> 16 & 0xFF).toString(16) + (i >> 8 & 0xFF).toString(16) + (i & 0xFF).toString(16);
        hex += '000000';
        return hex.substring(0, 6);
    }
};
exports.default = graph;

/***/ }),

/***/ 239:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
// commit msg credit go to: whatthecommit   :)
var data = [["master", "bb35615 01-01-2018", "init project"], ["master", "7e6843b 01-02-2018", "I should have had a V8 this morning."], ["master", "c342f2f 01-04-2018", "I will not apologize for art."], ["master>new-feature", "87ee6bf 01-05-2018", "Update .gitignore"], ["master<new-feature", "1a8501f 01-05-2018", "merged"], ["master", "2eab2b6 01-06-2018", "Stuff"], ["master>sub-system", "2eab2b6 01-07-2018", "Test commit. Please ignore"], ["sub-system", "158b65a 01-06-2018", "Fixed a bug cause Jason said to"], ["master>ateam", "ce6d865 01-06-2018", "Herping the derp"], ["master<sub-system", "09eef0d 01-07-2018", "."], ["master<ateam", "856c6c2 01-07-2018", "Working on tests (haha)"], ["master", "d93e386 01-010-2018", "sync"]];
exports.default = data;

/***/ }),

/***/ 6:
/***/ (function(module, exports) {

"use strict";
throw new Error("Module build failed: Error: ENOENT: no such file or directory, open 'C:\\UwAmp\\www\\glg\\client\\node_modules\\react\\react.js'\n    at Error (native)");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgODhhOGRkODY3ZTZhOWRlNmIxMzIiLCJ3ZWJwYWNrOi8vLy4vcm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL0xheW91dC5qcyIsIndlYnBhY2s6Ly8vLi91dGlscy9ncmFwaC5qcyIsIndlYnBhY2s6Ly8vLi9kYXRhL2RhdGEuanMiXSwibmFtZXMiOlsiYnVpbGRSb3V0ZXMiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiTGF5b3V0IiwicHJvcHMiLCJzdGF0ZSIsInZpZXdlcnMiLCJjb25zb2xlIiwibG9nIiwiZ3JhcGhWaWV3IiwiZHJhdyIsIkNvbXBvbmVudCIsIkJSQU5DSCIsIkRBVEUiLCJNU0ciLCJncmFwaCIsImJyYW5jaGVzIiwiaW5pdCIsImN1cnJCcmFuY2hlcyIsIm1hcCIsImNvbW1pdCIsImkiLCJicmFuY2hJZHgiLCJPYmplY3QiLCJrZXlzIiwiaW5kZXhPZiIsImxlbmd0aCIsImJyYW5jaENsYXNzIiwiY29sb3IiLCJ0b0hleENvbG9yIiwicHVzaCIsIk1hdGgiLCJyYW5kb20iLCJiTmFtZSIsImhvckxpbmUiLCJob3JMaW5lMiIsImlzQWZ0ZXJCcmFuY2hFbmQiLCJjYiIsImoiLCJiIiwic3BsaXQiLCJzcGxpY2UiLCJpbmNsdWRlcyIsInJldmVyc2UiLCJhc3NpZ24iLCJzdHIiLCJpbnRUb0FSR0IiLCJoYXNoQ29kZSIsImhhc2giLCJjaGFyQ29kZUF0IiwiaGV4IiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJkYXRhIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7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SFMsRUFJVCxDQUFDLG9CQUFELEVBQXVCLG9CQUF2QixFQUE2QyxtQkFBN0MsQ0FKUyxFQUtULENBQUMsb0JBQUQsRUFBdUIsb0JBQXZCLEVBQTZDLFFBQTdDLENBTFMsRUFNVCxDQUFDLFFBQUQsRUFBVyxvQkFBWCxFQUFpQyxPQUFqQyxDQU5TLEVBT1QsQ0FBQyxtQkFBRCxFQUFzQixvQkFBdEIsRUFBNEMsNEJBQTVDLENBUFMsRUFRVCxDQUFDLFlBQUQsRUFBZSxvQkFBZixFQUFxQyxpQ0FBckMsQ0FSUyxFQVNULENBQUMsY0FBRCxFQUFpQixvQkFBakIsRUFBdUMsa0JBQXZDLENBVFMsRUFVVCxDQUFDLG1CQUFELEVBQXNCLG9CQUF0QixFQUE0QyxHQUE1QyxDQVZTLEVBV1osQ0FBQyxjQUFELEVBQWlCLG9CQUFqQixFQUF1Qyx5QkFBdkMsQ0FYWSxFQVlaLENBQUMsUUFBRCxFQUFXLHFCQUFYLEVBQWtDLE1BQWxDLENBWlksQ0FBYjtrQkFjZUEsSSIsImZpbGUiOiJnbGcubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTEzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA4OGE4ZGQ4NjdlNmE5ZGU2YjEzMiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7cmVuZGVyfSBmcm9tICdyZWFjdC1kb20nO1xyXG5pbXBvcnQgeyBSb3V0ZXIsIFJvdXRlLCBicm93c2VySGlzdG9yeSB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XHJcblxyXG5pbXBvcnQgTGF5b3V0IGZyb20gXCIuL2NvbXBvbmVudHMvTGF5b3V0XCI7XHJcblxyXG5mdW5jdGlvbiBidWlsZFJvdXRlcygpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFJvdXRlciBoaXN0b3J5PXticm93c2VySGlzdG9yeX0+XHJcbiAgICAgICAgICAgIDxSb3V0ZSBwYXRoPVwiL1wiIGNvbXBvbmVudD17TGF5b3V0fSA+XHJcbiAgICAgICAgICAgIDwvUm91dGU+XHJcbiAgICAgICAgPC9Sb3V0ZXI+XHJcbiAgICApXHJcbn1cclxuXHJcbnJlbmRlcihidWlsZFJvdXRlcygpLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2xnJykpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3Jvb3QuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgZ3JhcGggZnJvbSBcIi4uL3V0aWxzL2dyYXBoXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheW91dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge3ZpZXdlcnM6IG51bGx9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnN0YXRlKTtcbiAgICAgICAgY29uc3QgZ3JhcGhWaWV3ID0gZ3JhcGguZHJhdygpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdjdi1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAge2dyYXBoVmlld31cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvbXBvbmVudHMvTGF5b3V0LmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xyXG5pbXBvcnQgZGF0YSBmcm9tIFwiLi4vZGF0YS9kYXRhXCI7XHJcblxyXG5jb25zdCBCUkFOQ0ggID0gMDtcclxuY29uc3QgREFURSAgPSAxO1xyXG5jb25zdCBNU0cgID0gMjtcclxuXHJcbmNvbnN0IGdyYXBoID0ge1xyXG5cclxuICAgIGRyYXcoKSAge1xyXG4gICAgICAgIHRoaXMuYnJhbmNoZXMgPSB0aGlzLmluaXQoKTtcclxuICAgICAgICBsZXQgZ3JhcGhWaWV3ID0gW107XHJcbiAgICAgICAgbGV0IGN1cnJCcmFuY2hlcyA9IFtdO1xyXG5cclxuICAgICAgICBkYXRhLm1hcCgoY29tbWl0LCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJyYW5jaElkeCA9IE9iamVjdC5rZXlzKHRoaXMuYnJhbmNoZXMpLmluZGV4T2YoY29tbWl0W0JSQU5DSF0pO1xyXG5cclxuICAgICAgICAgICAgLy9icmFuY2ggZW5kZWQgcGFydFxyXG4gICAgICAgICAgICAvL2VuZCBsYXN0IGJyYW5jaFxyXG4gICAgICAgICAgICBpZihkYXRhLmxlbmd0aC0xID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBicmFuY2hDbGFzcyA9IHtjb2xvcjogdGhpcy50b0hleENvbG9yKGNvbW1pdFtCUkFOQ0hdKX07XHJcbiAgICAgICAgICAgICAgICBncmFwaFZpZXcucHVzaChcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17TWF0aC5yYW5kb20oKX0+PHNwYW4gc3R5bGU9e2JyYW5jaENsYXNzfT4qIDwvc3Bhbj4ge2NvbW1pdFtEQVRFXX0gfCB7Y29tbWl0W01TR119PC9kaXY+XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9lbmQgYW5kIG1lcmdlIGN1cnJlbnQgYnJhbmNoXHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYnJhbmNoZXMpLm1hcCgoYk5hbWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuYnJhbmNoZXNbYk5hbWVdID09PSBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhvckxpbmUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaG9yTGluZTIgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNBZnRlckJyYW5jaEVuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJCcmFuY2hlcy5tYXAoKGNiLCBqKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiID0gY29tbWl0W0JSQU5DSF0uc3BsaXQoLzwvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnJhbmNoQ2xhc3MgPSB7Y29sb3I6IHRoaXMudG9IZXhDb2xvcihjYil9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYiA9PT0gYlsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBZnRlckJyYW5jaEVuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3JMaW5lLnB1c2goPHNwYW4ga2V5PXtNYXRoLnJhbmRvbSgpfSBzdHlsZT17YnJhbmNoQ2xhc3N9PlxcIDwvc3Bhbj4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9yTGluZTIuc3BsaWNlKGhvckxpbmUyLmxlbmd0aC0xLCAxLCA8c3BhbiBrZXk9e01hdGgucmFuZG9tKCl9IHN0eWxlPXticmFuY2hDbGFzc30+KiA8L3NwYW4+KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvckxpbmUucHVzaCg8c3BhbiBrZXk9e01hdGgucmFuZG9tKCl9IHN0eWxlPXticmFuY2hDbGFzc30+e2lzQWZ0ZXJCcmFuY2hFbmQgPyBcIlxcXFwgXCIgOiBcInwgXCJ9PC9zcGFuPik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3JMaW5lMi5wdXNoKDxzcGFuIGtleT17TWF0aC5yYW5kb20oKX0gc3R5bGU9e2JyYW5jaENsYXNzfT57aXNBZnRlckJyYW5jaEVuZCA/IFwifCBcIiA6IFwiXFxcXCBcIn08L3NwYW4+KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoVmlldy5wdXNoKDxkaXYga2V5PXtNYXRoLnJhbmRvbSgpfT57aG9yTGluZX08L2Rpdj4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoVmlldy5wdXNoKDxkaXYga2V5PXtNYXRoLnJhbmRvbSgpfT57aG9yTGluZTJ9IHtjb21taXRbREFURV19IHwge2NvbW1pdFtNU0ddfTwvZGl2Pik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VyckJyYW5jaGVzLnNwbGljZShjdXJyQnJhbmNoZXMuaW5kZXhPZihiTmFtZSksIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vbWFzdGVyIHN0YXJ0XHJcbiAgICAgICAgICAgIGlmKGk9PT0wKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyQnJhbmNoZXMucHVzaChjb21taXRbQlJBTkNIXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBicmFuY2hDbGFzcyA9IHtjb2xvcjogdGhpcy50b0hleENvbG9yKGNvbW1pdFtCUkFOQ0hdKX07XHJcbiAgICAgICAgICAgICAgICBncmFwaFZpZXcucHVzaCg8ZGl2IGtleT17TWF0aC5yYW5kb20oKX0+PHNhcG4gc3R5bGU9e2JyYW5jaENsYXNzfSA+KiA8L3NhcG4+IHtjb21taXRbREFURV19IHwge2NvbW1pdFtNU0ddfTwvZGl2Pik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9jcmVhdGluZyBicmFuY2hcclxuICAgICAgICAgICAgZWxzZSBpZiAoY29tbWl0W0JSQU5DSF0uaW5jbHVkZXMoXCI+XCIpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYiA9IGNvbW1pdFtCUkFOQ0hdLnNwbGl0KC8+Lyk7XHJcbiAgICAgICAgICAgICAgICBjdXJyQnJhbmNoZXMucHVzaChiWzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaG9yTGluZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbGV0IGhvckxpbmUyID0gW107XHJcbiAgICAgICAgICAgICAgICBjdXJyQnJhbmNoZXMubWFwKChjYiwgaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJyYW5jaENsYXNzID0ge2NvbG9yOiB0aGlzLnRvSGV4Q29sb3IoY2IpfTtcclxuICAgICAgICAgICAgICAgICAgICBob3JMaW5lLnB1c2goPHNwYW4ga2V5PXtNYXRoLnJhbmRvbSgpfSAgc3R5bGU9e2JyYW5jaENsYXNzfT4ge2NiID09PSBiWzFdID8gXCIvIFwiIDogXCJ8IFwifTwvc3Bhbj4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvckxpbmUyLnB1c2goPHNwYW4ga2V5PXtNYXRoLnJhbmRvbSgpfSBzdHlsZT17YnJhbmNoQ2xhc3N9PntjYiA9PT0gYlsxXSA/IFwiKiAgXCIgOiBcInwgXCJ9PC9zcGFuPik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGdyYXBoVmlldy5wdXNoKDxkaXYga2V5PXtNYXRoLnJhbmRvbSgpfSA+e2hvckxpbmV9PC9kaXY+KTtcclxuICAgICAgICAgICAgICAgIGdyYXBoVmlldy5wdXNoKDxkaXYga2V5PXtNYXRoLnJhbmRvbSgpfSA+e2hvckxpbmUyfSB7Y29tbWl0W0RBVEVdfSB8IHtjb21taXRbTVNHXX08L2Rpdj4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vbWVyZ2luZyBiYWNrXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1pdFtCUkFOQ0hdLmluY2x1ZGVzKFwiPFwiKSApe1xyXG4gICAgICAgICAgICAgICAgbGV0IGIgPSBjb21taXRbQlJBTkNIXS5zcGxpdCgvPC8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vbmV3IGJyYW5jaFxyXG4gICAgICAgICAgICBlbHNlIGlmIChicmFuY2hJZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyQnJhbmNoZXMucHVzaChjb21taXRbQlJBTkNIXSk7XHJcbiAgICAgICAgICAgICAgICBncmFwaFZpZXcucHVzaCg8ZGl2IGtleT17TWF0aC5yYW5kb20oKX0gPnwvIHtjb21taXRbREFURV19IHwge2NvbW1pdFtNU0ddfTwvZGl2Pik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9jb21taXRcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaG9yTGluZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgY3VyckJyYW5jaGVzLm1hcCgoY2IsIGopID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBicmFuY2hDbGFzcyA9IHtjb2xvcjogdGhpcy50b0hleENvbG9yKGNiKX07XHJcbiAgICAgICAgICAgICAgICAgICAgaG9yTGluZS5wdXNoKDxzcGFuIGtleT17YCR7Y2J9XyR7aX1fJHtqfWB9IHN0eWxlPXticmFuY2hDbGFzc30+e2NiID09PSBjb21taXRbQlJBTkNIXSA/IFwiKiBcIiA6IFwifCBcIn08L3NwYW4+KTtcclxuICAgICAgICAgICAgICAgICAgICAvL2hvckxpbmUgPSBjYiA9PT0gY29tbWl0W0JSQU5DSF0gPyBob3JMaW5lICsgXCIqIFwiIDogaG9yTGluZSArIFwifCBcIjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhWaWV3LnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e01hdGgucmFuZG9tKCl9Pntob3JMaW5lfSB7Y29tbWl0W0RBVEVdfSB8IHtjb21taXRbTVNHXX08L2Rpdj5cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZ3JhcGhWaWV3LnJldmVyc2UoKTtcclxuICAgIH0sXHJcblxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICB0aGlzLmJyYW5jaGVzID0ge307XHJcblxyXG4gICAgICAgIC8vZ2V0dGluZyBicmFuY2hlcyBleGlzdCBhbmQgd2hlbiBlbmRlZFxyXG4gICAgICAgIGRhdGEubWFwKChjb21taXQsIGkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYnJhbmNoSWR4ID0gT2JqZWN0LmtleXModGhpcy5icmFuY2hlcykuaW5kZXhPZihjb21taXRbQlJBTkNIXSk7XHJcbiAgICAgICAgICAgIGlmIChjb21taXRbQlJBTkNIXS5pbmNsdWRlcyhcIjxcIikgfHwgY29tbWl0W0JSQU5DSF0uaW5jbHVkZXMoXCI+XCIpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYiA9IGNvbW1pdFtCUkFOQ0hdLnNwbGl0KC8+fDwvKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnJhbmNoZXNbYlswXV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5icmFuY2hlc1tiWzFdXSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYnJhbmNoSWR4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmJyYW5jaGVzLCB7W2NvbW1pdFtCUkFOQ0hdXTogaX0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5icmFuY2hlc1tjb21taXRbQlJBTkNIXV0gPSBpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5icmFuY2hlcztcclxuICAgIH0sXHJcblxyXG5cdC8qIGNyZWRpdCBmb3Igc29sdXRpb24gY29udmVydGluZyBzdHJpbmcgdG8gcmdiIGhleCBjb2RlXHJcblx0ICogZGVzaWduZWRieWF0dXJ0bGUuY28udWsvMjAxNC9jb252ZXJ0LXN0cmluZy10by1oZXhpZGVjaW1hbC1jb2xvdXItd2l0aC1qYXZhc2NyaXB0LXZhbmlsbGFcclxuXHQgKi9cclxuICAgIHRvSGV4Q29sb3Ioc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiI1wiK3RoaXMuaW50VG9BUkdCKHRoaXMuaGFzaENvZGUoc3RyKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGhhc2hDb2RlKHN0cikge1xyXG4gICAgICAgIGxldCBoYXNoID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBoYXNoID0gc3RyLmNoYXJDb2RlQXQoaSkgKyAoKGhhc2ggPDwgNSkgLSBoYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICB9LFxyXG5cclxuICAgIGludFRvQVJHQihpKSB7XHJcbiAgICAgICAgbGV0IGhleCA9ICgoaT4+MjQpJjB4RkYpLnRvU3RyaW5nKDE2KSArXHJcbiAgICAgICAgICAgICgoaT4+MTYpJjB4RkYpLnRvU3RyaW5nKDE2KSArXHJcbiAgICAgICAgICAgICgoaT4+OCkmMHhGRikudG9TdHJpbmcoMTYpICtcclxuICAgICAgICAgICAgKGkmMHhGRikudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIGhleCArPSAnMDAwMDAwJztcclxuICAgICAgICByZXR1cm4gaGV4LnN1YnN0cmluZygwLCA2KTtcclxuICAgIH1cclxufTtcclxuZXhwb3J0IGRlZmF1bHQgZ3JhcGg7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdXRpbHMvZ3JhcGguanMiLCIvLyBjb21taXQgbXNnIGNyZWRpdCBnbyB0bzogd2hhdHRoZWNvbW1pdCAgIDopXHJcbmNvbnN0IGRhdGEgPSBbXHJcbiAgICBbXCJtYXN0ZXJcIiwgXCJiYjM1NjE1IDAxLTAxLTIwMThcIiwgXCJpbml0IHByb2plY3RcIl0sXHJcbiAgICBbXCJtYXN0ZXJcIiwgXCI3ZTY4NDNiIDAxLTAyLTIwMThcIiwgXCJJIHNob3VsZCBoYXZlIGhhZCBhIFY4IHRoaXMgbW9ybmluZy5cIl0sXHJcbiAgICBbXCJtYXN0ZXJcIiwgXCJjMzQyZjJmIDAxLTA0LTIwMThcIiwgXCJJIHdpbGwgbm90IGFwb2xvZ2l6ZSBmb3IgYXJ0LlwiXSxcclxuICAgIFtcIm1hc3Rlcj5uZXctZmVhdHVyZVwiLCBcIjg3ZWU2YmYgMDEtMDUtMjAxOFwiLCBcIlVwZGF0ZSAuZ2l0aWdub3JlXCJdLFxyXG4gICAgW1wibWFzdGVyPG5ldy1mZWF0dXJlXCIsIFwiMWE4NTAxZiAwMS0wNS0yMDE4XCIsIFwibWVyZ2VkXCJdLFxyXG4gICAgW1wibWFzdGVyXCIsIFwiMmVhYjJiNiAwMS0wNi0yMDE4XCIsIFwiU3R1ZmZcIl0sXHJcbiAgICBbXCJtYXN0ZXI+c3ViLXN5c3RlbVwiLCBcIjJlYWIyYjYgMDEtMDctMjAxOFwiLCBcIlRlc3QgY29tbWl0LiBQbGVhc2UgaWdub3JlXCJdLFxyXG4gICAgW1wic3ViLXN5c3RlbVwiLCBcIjE1OGI2NWEgMDEtMDYtMjAxOFwiLCBcIkZpeGVkIGEgYnVnIGNhdXNlIEphc29uIHNhaWQgdG9cIl0sXHJcbiAgICBbXCJtYXN0ZXI+YXRlYW1cIiwgXCJjZTZkODY1IDAxLTA2LTIwMThcIiwgXCJIZXJwaW5nIHRoZSBkZXJwXCJdLFxyXG4gICAgW1wibWFzdGVyPHN1Yi1zeXN0ZW1cIiwgXCIwOWVlZjBkIDAxLTA3LTIwMThcIiwgXCIuXCJdLFxyXG5cdFtcIm1hc3RlcjxhdGVhbVwiLCBcIjg1NmM2YzIgMDEtMDctMjAxOFwiLCBcIldvcmtpbmcgb24gdGVzdHMgKGhhaGEpXCJdLFxyXG5cdFtcIm1hc3RlclwiLCBcImQ5M2UzODYgMDEtMDEwLTIwMThcIiwgXCJzeW5jXCJdLFxyXG5dO1xyXG5leHBvcnQgZGVmYXVsdCBkYXRhO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RhdGEvZGF0YS5qcyJdLCJzb3VyY2VSb290IjoiIn0=